import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { execa } from 'execa';
import readline from 'node:readline';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export interface InitOptions {
  framework: 'vite' | 'next' | 'cra' | 'static';
  packaging: 'capacitor' | 'tauri' | 'twa';
  firebase?: boolean;
  firebaseProjectId?: string;
  firebaseApiKey?: string;
  allPlugins?: boolean;
}

export async function initProject(options: InitOptions): Promise<void> {
  const cwd = process.cwd();
  const configPath = path.join(cwd, 'deploid.config.ts');
  
  // Check if config already exists
  if (fs.existsSync(configPath)) {
    console.log('‚ö†Ô∏è  deploid.config.ts already exists. Skipping init.');
    return;
  }

  // If no Firebase options provided, ask interactively
  if (options.packaging === 'capacitor' && options.firebase === undefined) {
    const firebaseSetup = await askFirebaseSetup();
    options.firebase = firebaseSetup.enabled;
    options.firebaseProjectId = firebaseSetup.projectId;
    options.firebaseApiKey = firebaseSetup.apiKey;
  }

  // Generate config based on options
  const config = generateConfig(options);
  
  // Write config file
  fs.writeFileSync(configPath, config);
  console.log('‚úÖ Created deploid.config.ts');

  // Create basic project structure
  await createProjectStructure(cwd, options);
  
  // Install required dependencies
  await installDependencies(cwd, options);
  
  // Setup Firebase if requested
  if (options.firebase && options.packaging === 'capacitor') {
    await setupFirebase(cwd, options);
  }
  
  // Install plugin dependencies
  console.log('üì¶ Installing plugin dependencies...');
  await installPluginDependencies(cwd, options);
  
  console.log('üéâ Deploid initialized!');
  console.log('Next steps:');
  console.log('  1. Add your logo to assets/logo.svg');
  console.log('  2. Run: deploid assets');
  console.log('  3. Run: deploid package');
}

function generateConfig(options: InitOptions): string {
  const { framework, packaging, firebase, firebaseProjectId } = options;
  
  const buildCommand = getBuildCommand(framework);
  const webDir = getWebDir(framework);
  
  const firebaseConfig = firebase ? `
  firebase: {
    projectId: '${firebaseProjectId || 'your-firebase-project-id'}',
    enabled: true,
  },` : '';
  
  return `// Deploid configuration
// Generated by deploid init

export default {
  appName: 'MyApp',
  appId: 'com.example.myapp',
  web: {
    framework: '${framework}',
    buildCommand: '${buildCommand}',
    webDir: '${webDir}',
    pwa: { manifest: 'public/manifest.json', serviceWorker: true },
  },
  android: {
    packaging: '${packaging}',
    targetSdk: 34,
    minSdk: 24,
    permissions: ['INTERNET'],
    version: { code: 1, name: '1.0.0' },
  },${firebaseConfig}
  assets: {
    source: 'assets/logo.svg',
    output: 'assets-gen/',
  },
  publish: {
    github: { repo: 'your-username/your-repo', draft: true },
  },
};
`;
}

function getBuildCommand(framework: string): string {
  switch (framework) {
    case 'vite': return 'npm run build';
    case 'next': return 'npm run build';
    case 'cra': return 'npm run build';
    case 'static': return 'echo "Static files ready"';
    default: return 'npm run build';
  }
}

function getWebDir(framework: string): string {
  switch (framework) {
    case 'vite': return 'dist';
    case 'next': return 'out';
    case 'cra': return 'build';
    case 'static': return 'public';
    default: return 'dist';
  }
}

async function createProjectStructure(cwd: string, options: InitOptions): Promise<void> {
  // Create assets directory
  const assetsDir = path.join(cwd, 'assets');
  if (!fs.existsSync(assetsDir)) {
    fs.mkdirSync(assetsDir, { recursive: true });
    console.log('‚úÖ Created assets/ directory');
  }

  // Create assets-gen directory
  const assetsGenDir = path.join(cwd, 'assets-gen');
  if (!fs.existsSync(assetsGenDir)) {
    fs.mkdirSync(assetsGenDir, { recursive: true });
    console.log('‚úÖ Created assets-gen/ directory');
  }

  // Create template files based on packaging engine
  await createTemplateFiles(cwd, options.packaging);
}

async function installDependencies(cwd: string, options: InitOptions): Promise<void> {
  console.log('üì¶ Installing required dependencies...');
  
  try {
    // Install Capacitor CLI and core packages
    await execa('npm', ['install', '@capacitor/cli', '@capacitor/core'], { 
      cwd, 
      stdio: 'inherit' 
    });
    
    // Install platform-specific packages based on packaging engine
    switch (options.packaging) {
      case 'capacitor':
        await execa('npm', ['install', '@capacitor/android'], { 
          cwd, 
          stdio: 'inherit' 
        });
        break;
      case 'tauri':
        // TODO: Install Tauri dependencies
        console.log('‚ö†Ô∏è  Tauri packaging not yet implemented');
        break;
      case 'twa':
        // TODO: Install TWA dependencies
        console.log('‚ö†Ô∏è  TWA packaging not yet implemented');
        break;
    }
    
    console.log('‚úÖ Dependencies installed');
  } catch (error) {
    console.log('‚ö†Ô∏è  Failed to install dependencies automatically');
    console.log('Please run manually:');
    console.log('  npm install @capacitor/cli @capacitor/core @capacitor/android');
  }
}

async function createTemplateFiles(cwd: string, packaging: string): Promise<void> {
  const templatesDir = path.join(__dirname, '../../templates');
  
  switch (packaging) {
    case 'capacitor':
      await createCapacitorTemplate(cwd);
      break;
    case 'tauri':
      await createTauriTemplate(cwd);
      break;
    case 'twa':
      await createTWATemplate(cwd);
      break;
  }
}

async function createCapacitorTemplate(cwd: string): Promise<void> {
  const capacitorConfig = `{
  "appId": "com.example.myapp",
  "appName": "MyApp",
  "webDir": "dist",
  "bundledWebRuntime": false,
  "plugins": {
    "SplashScreen": {
      "launchShowDuration": 2000
    }
  }
}`;

  fs.writeFileSync(path.join(cwd, 'capacitor.config.json'), capacitorConfig);
  console.log('‚úÖ Created capacitor.config.json');
}

async function createTauriTemplate(cwd: string): Promise<void> {
  const tauriConfig = `{
  "build": {
    "beforeDevCommand": "npm run dev",
    "beforeBuildCommand": "npm run build",
    "devPath": "http://localhost:3000",
    "distDir": "../dist"
  },
  "package": {
    "productName": "MyApp",
    "version": "1.0.0"
  },
  "tauri": {
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "com.example.myapp",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ]
    },
    "security": {
      "csp": null
    },
    "windows": [
      {
        "fullscreen": false,
        "resizable": true,
        "title": "MyApp",
        "width": 1200,
        "height": 800
      }
    ]
  }
}`;

  fs.writeFileSync(path.join(cwd, 'src-tauri/tauri.conf.json'), tauriConfig);
  console.log('‚úÖ Created tauri.conf.json');
}

async function createTWATemplate(cwd: string): Promise<void> {
  const manifest = `{
  "name": "MyApp",
  "short_name": "MyApp",
  "description": "My awesome app",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#000000",
  "icons": [
    {
      "src": "assets-gen/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "assets-gen/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}`;

  fs.writeFileSync(path.join(cwd, 'public/manifest.json'), manifest);
  console.log('‚úÖ Created public/manifest.json');
}

async function askFirebaseSetup(): Promise<{ enabled: boolean; projectId?: string; apiKey?: string }> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  const question = (prompt: string): Promise<string> => {
    return new Promise((resolve) => {
      rl.question(prompt, resolve);
    });
  };

  try {
    console.log('\nüî• Firebase Setup for Push Notifications');
    console.log('Firebase enables native push notifications for your Android app.');
    
    const enableFirebase = await question('Do you want to set up Firebase for push notifications? (y/N): ');
    const enabled = enableFirebase.toLowerCase().startsWith('y');
    
    if (!enabled) {
      console.log('‚ö†Ô∏è  Skipping Firebase setup. You can add it later with: deploid firebase');
      return { enabled: false };
    }

    console.log('\nüìã Firebase Setup Options:');
    console.log('1. Auto-create Firebase project (requires Firebase CLI)');
    console.log('2. Use existing Firebase project');
    console.log('3. Skip for now (add later with: shipwright firebase)');
    
    const choice = await question('Choose an option (1-3): ');
    
    if (choice === '3') {
      console.log('‚ö†Ô∏è  Skipping Firebase setup. You can add it later with: deploid firebase');
      return { enabled: false };
    }
    
    if (choice === '1') {
      console.log('üöÄ Auto-creating Firebase project...');
      return { enabled: true };
    }
    
    if (choice === '2') {
      const projectId = await question('Enter your Firebase project ID: ');
      const apiKey = await question('Enter your Firebase API key (optional): ');
      return { enabled: true, projectId, apiKey };
    }
    
    return { enabled: false };
  } finally {
    rl.close();
  }
}

async function setupFirebase(cwd: string, options: InitOptions): Promise<void> {
  console.log('üî• Setting up Firebase...');
  
  try {
    // Check if Firebase CLI is installed
    try {
      await execa('firebase', ['--version'], { stdio: 'pipe' });
    } catch (error) {
      console.log('üì¶ Installing Firebase CLI...');
      await execa('npm', ['install', '-g', 'firebase-tools'], { stdio: 'inherit' });
    }
    
    // Login to Firebase
    console.log('üîê Please login to Firebase...');
    await execa('firebase', ['login'], { stdio: 'inherit' });
    
    // Create Firebase project
    if (!options.firebaseProjectId) {
      console.log('üöÄ Creating Firebase project...');
      const projectName = path.basename(cwd).replace(/[^a-zA-Z0-9]/g, '-');
      await execa('firebase', ['projects:create', projectName], { stdio: 'inherit' });
      options.firebaseProjectId = projectName;
    }
    
    // Initialize Firebase in the project
    await execa('firebase', ['init', 'hosting'], { 
      cwd, 
      stdio: 'inherit',
      input: 'y\nn\n' // Yes to hosting, no to other features
    });
    
    // Add Android app to Firebase
    console.log('üì± Adding Android app to Firebase...');
    const packageName = 'com.example.myapp'; // This should come from config
    await execa('firebase', ['apps:create', 'android', packageName], { 
      cwd, 
      stdio: 'inherit' 
    });
    
    // Download google-services.json
    console.log('üìÑ Downloading google-services.json...');
    await execa('firebase', ['apps:sdkconfig', 'android'], { 
      cwd, 
      stdio: 'inherit' 
    });
    
    // Move google-services.json to correct location
    const sourcePath = path.join(cwd, 'google-services.json');
    const targetPath = path.join(cwd, 'android/app/google-services.json');
    
    if (fs.existsSync(sourcePath)) {
      fs.copyFileSync(sourcePath, targetPath);
      fs.unlinkSync(sourcePath); // Remove from root
      console.log('‚úÖ Firebase setup complete!');
    } else {
      console.log('‚ö†Ô∏è  google-services.json not found. Please download it manually from Firebase Console.');
    }
    
  } catch (error) {
    console.log('‚ö†Ô∏è  Firebase setup failed:', error);
    console.log('You can set it up manually later with: deploid firebase');
  }
}

async function installPluginDependencies(cwd: string, options: InitOptions): Promise<void> {
  try {
    // Define available plugins
    const availablePlugins = {
      'assets': {
        name: 'deploid-plugin-assets',
        description: 'Generate app icons and assets from your logo',
        required: true // Always needed for basic functionality
      },
      'packaging-capacitor': {
        name: 'deploid-plugin-packaging-capacitor',
        description: 'Package your app with Capacitor',
        required: options.packaging === 'capacitor'
      },
      'build-android': {
        name: 'deploid-plugin-build-android',
        description: 'Build Android APK/AAB files',
        required: true // Always needed for Android builds
      },
      'deploy-android': {
        name: 'deploid-plugin-deploy-android',
        description: 'Deploy to Android devices via ADB',
        required: false
      },
      'prepare-ios': {
        name: 'deploid-plugin-prepare-ios',
        description: 'Prepare iOS project for Mac handoff',
        required: false
      },
      'debug-network': {
        name: 'deploid-plugin-debug-network',
        description: 'Add network debugging tools to your app',
        required: false
      },
      'storage': {
        name: 'deploid-plugin-storage',
        description: 'Cross-platform storage utilities for web and native',
        required: false
      }
    };

    // Collect plugins to install
    const pluginsToInstall: string[] = [];
    
    // Add required plugins
    for (const [key, plugin] of Object.entries(availablePlugins)) {
      if (plugin.required) {
        pluginsToInstall.push(plugin.name);
        console.log(`‚úÖ ${plugin.description} (required)`);
      }
    }

    // Ask about optional plugins
    if (options.allPlugins) {
      console.log('\nüîß Installing all optional plugins...');
      for (const [key, plugin] of Object.entries(availablePlugins)) {
        if (!plugin.required) {
          pluginsToInstall.push(plugin.name);
          console.log(`‚úÖ ${plugin.description}`);
        }
      }
    } else {
      console.log('\nüîß Optional plugins:');
      for (const [key, plugin] of Object.entries(availablePlugins)) {
        if (!plugin.required) {
          const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
          });
          
          const answer = await new Promise<string>((resolve) => {
            rl.question(`Install ${plugin.description}? (y/N): `, resolve);
          });
          rl.close();
          
          if (answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes') {
            pluginsToInstall.push(plugin.name);
            console.log(`‚úÖ ${plugin.description}`);
          } else {
            console.log(`‚è≠Ô∏è  Skipped ${plugin.description}`);
          }
        }
      }
    }
    
    if (pluginsToInstall.length === 0) {
      console.log('‚ö†Ô∏è  No plugins selected. You can install them later with: npm install <plugin-name>');
      return;
    }
    
    console.log(`\nüì¶ Installing: ${pluginsToInstall.join(', ')}`);
    await execa('npm', ['install', ...pluginsToInstall], { 
      cwd, 
      stdio: 'inherit' 
    });
    
    console.log('‚úÖ Plugin packages installed');
  } catch (error) {
    console.log('‚ö†Ô∏è  Failed to install plugin packages:', error);
    console.log('You can install them manually later with: npm install <plugin-name>');
  }
}
